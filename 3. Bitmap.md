# Bitmap
Redis中的Bitmap是一种高效的数据结构，用于处理大量的二进制位数据。虽然Bitmap不是Redis中独立的数据类型，但它基于字符串类型(String)实现，通过对字符串的每个字节的位(bit)进行操作，来达到存储和计算的目的。Bitmap的核心优势在于其空间效率极高，特别适用于需要统计大量布尔型属性或者追踪用户行为等场景。

### Bitmap的工作原理

Bitmap将每个bit位映射到一个元素的状态上，0通常表示该元素的特定属性为“未发生”或“false”，而1则表示“已发生”或“true”。由于一个字节由8个bit组成，因此Bitmap能够以极小的空间存储大量元素的状态信息。例如，一个字节可以表示8个不同元素的二值状态。

### Bitmap的常用命令

- `SETBIT key offset value`：设置指定偏移量的bit位为value（0或1）。
- `GETBIT key offset`：获取指定偏移量的bit位的值。
- `BITCOUNT key [start end]`：统计key中被设置为1的bit位数量，可选地限制在[start, end]范围内。
- 还有其他诸如`BITOP`（执行位操作，如AND、OR、NOT、XOR）、`BITFIELD`（执行复杂的位字段操作）等高级命令。

### 应用场景

1. **用户签到系统**：可以用一个Bitmap来记录用户在一年中的每一天是否签到，每个用户对应一个Bitmap，偏移量对应日期，值表示当天是否签到，极大地节省了存储空间。
   
2. **用户特征标记**：在大数据分析中，可以使用Bitmap来标记用户的某些特征是否出现，例如用户是否点击了某个广告、是否购买了某类商品等，便于快速统计和分析用户行为。

3. **权限管理**：Bitmap可以用来实现简单的权限系统，每位代表一个权限，用户是否有该权限通过位的值来表示，查询权限时只需读取对应位即可，高效且节省空间。

4. **去重计数**：例如，在统计网站唯一访客时，可以为每个用户分配一个bit位，通过Bitmap来记录用户的访问状态，实现海量数据的快速去重计数。

5. **社交网络中的好友关系**：两个Bitmap可以分别代表两个用户的好友列表，通过位运算可以快速找出共同好友、唯一好友等信息。

Bitmap因其空间高效性和快速的位操作特性，在处理大量布尔型数据的场景中表现出色，是Redis中一种强大且灵活的工具。

实例：
```
[root@VM-0-2-centos ~]# docker exec -it myredis redis-cli
127.0.0.1:6379> setbit tb 1 1
(integer) 0
127.0.0.1:6379> setbit tb 2 1
(integer) 0
127.0.0.1:6379> setbit tb 3 1
(integer) 0
127.0.0.1:6379> setbit tb 5 1
(integer) 0
127.0.0.1:6379> setbit tb 9 1
(integer) 0
127.0.0.1:6379> bitcount tb 0 1
(integer) 5
127.0.0.1:6379> bitcount tb 0 0
(integer) 4
127.0.0.1:6379> bitcount tb 1 1
(integer) 1
```
bitcount 0 1 就是第一个字节和第二个字节中1的数量的（1byte = 8bit）。

<br>

## bitmap的优势、限制
### 优势
- 1.基于最小的单位bit进行存储，所以非常省空间。
- 2.设置时候时间复杂度O(1)、读取时候时间复杂度O(n)，操作是非常快的。
- 3.二进制数据的存储，进行相关计算的时候非常快。
- 4.方便扩容

### 限制
redis中bit映射被限制在512MB之内，所以最大是2^32位。建议每个key的位数都控制下，因为读取时候时间复杂度O(n)，越大的串读的时间花销越多。

bitmap空间、时间粗略计算方式
在一台2010MacBook Pro上，offset为2^32-1（分配512MB）需要～300ms，offset为2^30-1(分配128MB)需要～80ms，offset为2^28-1（分配32MB）需要～30ms，offset为2^26-1（分配8MB）需要8ms。<来自官方文档>

大概的空间占用计算公式是：
```
($offset/8/1024/1024)MB
```

<br>

## 应用
### 1）用户在线状态
需求分析：

需要对子项目提供一个接口，来提供某用户是否在线？

设计方案：

使用bitmap是一个节约空间效率又高的一种方法，只需要一个key，然后用户id为偏移量offset，如果在线就设置为1，不在线就设置为0，3亿用户只需要36MB的空间。

伪代码：
```
$status = 1;
$redis->setBit('online', $uid, $status);
$redis->getBit('online', $uid);
```
需要加上如例子1一样分片的方式。10亿真的太多了。10w分一片。

### 2）统计活跃用户
需求分析：

需要计算活跃用户的数据情况。

设计方案：

使用时间作为缓存的key，然后用户id为offset，如果当日活跃过就设置为1。之后通过bitOp进行二进制计算算出在某段时间内用户的活跃情况。

伪代码：
```
$status = 1;
$redis->setBit('active_20170708', $uid, $status);
$redis->setBit('active_20170709', $uid, $status);
$redis->bitOp('AND', 'active', 'active_20170708', 'active_20170709'); 
```
上亿用户需要加上如例子1一样分片的方式。几十万或者以下，可无需分片省的业务变复杂。
