# 击穿和雪崩
缓存击穿和缓存雪崩是缓存系统中常见的两种故障模式，它们都会对系统的稳定性和性能产生负面影响。

## 缓存击穿

**定义**：缓存击穿发生在某个热点键值（即被频繁访问的缓存项）的生命周期结束时, 恰好有大量的请求在同一时刻到来，这些请求因为找不到缓存中的数据，就会穿透到后端数据库，从而给数据库带来极大的压力，可能导致数据库服务受到影响，甚至崩溃。

**例子**：假设一个电商网站的商品详情页非常热门，特别是某款手机的详情页面（对应缓存键为"product:12345"），每天有成千上万的访问。一天晚上12点，这个商品详情页的缓存因为设置了24小时过期策略刚好失效，此时正值促销活动开始，瞬间有大量用户涌入访问这个商品详情，由于缓存未命中，所有请求直接打到了数据库，数据库无法承受如此之高的并发请求，导致响应缓慢甚至服务中断。

**解决方案**：
- 热点数据永不过期：对于热点数据，可以设置其永不过期，通过后台任务定时更新这些数据的缓存值。比如我们可以将某个 key 的缓存时间设置为 25 小时，然后后台有个 JOB 每隔 24 小时就去批量刷新一下热点数据
- 使用互斥锁：在访问数据库前加锁，确保只有第一个请求能够访问数据库，其余请求等待锁释放后直接从缓存中获取数据。容易影响吞吐量，大部分项目设置热点 key 永不过期就妥妥的了。

<br>

### 缓存穿透(绕过)
缓存穿透是指在高并发环境下，应用程序请求缓存中不存在的数据（这些数据在数据库中同样不存在），由于缓存未命中，请求会继续穿透到后端数据库进行查询。由于数据库中也没有这些数据，所以每次这样的请求都会直接到达数据库层面，但每次都只能得到空结果。这不仅浪费了数据库资源，增加了数据库的访问压力，而且失去了缓存层本应起到的保护作用，可能导致数据库负载过高甚至服务崩溃。

**举例说明**：想象一个电商网站，用户可以通过商品ID查询商品详情。如果有人尝试查询一个根本不存在的商品ID（比如一个随机生成的、远大于现有商品ID范围的数字），因为这个商品ID在数据库中不存在，自然也不会被缓存。如果这样的查询请求非常多，每次请求都会直接打到数据库，尽管每次查询结果都是空，但仍然会导致数据库承受大量无意义的查询压力，这就是缓存穿透。

**解决方法**包括：
1. **缓存空值**：对于查询结果为空的情况，也可以在缓存中设置一个空值（例如，设置一个短时间的过期时间），这样下次相同的请求可以直接从缓存中获取空结果，避免再次访问数据库。
2. **布隆过滤器**：使用布隆过滤器预先过滤掉那些肯定不存在的查询请求，布隆过滤器是一个空间效率高但是允许一定误判率的数据结构，可以用来判断一个元素是否可能在一个集合中。
3. **访问频率限制**：对连续访问不存在数据的请求源进行频率限制，避免恶意攻击或异常请求持续消耗数据库资源。
4. **业务逻辑优化**：在业务层面进行校验，比如检查请求参数的有效性，提前拦截无效请求，减少不必要的数据库访问。

<br>
  
## 缓存雪崩

**定义**：当缓存系统中大量数据同时失效，或者缓存服务本身出现故障（如集群大面积宕机），导致大量请求直接涌向后端数据库，这种现象称为缓存雪崩。这种情况会对数据库造成巨大压力，容易导致服务全面瘫痪。

**例子**：一个新闻网站使用了缓存来存储新闻文章的内容，假设所有的新闻缓存设置的过期时间都是早上8点，以便在新的一天开始时更新内容。然而，某天早上，缓存服务因为未预料的维护窗口突然重启，导致所有新闻文章的缓存同时丢失。这时，正值用户浏览高峰期，成千上万的用户请求直接冲击数据库，数据库不堪重负，最终导致整个网站无法正常提供服务。

**解决方案**：
- 错峰过期：避免将所有缓存的过期时间设置为同一时刻，可以随机分布在一定时间范围内，以分散请求压力。
- 多级缓存：使用本地缓存和分布式缓存相结合的多级缓存策略，即使分布式缓存出现问题，也能一定程度上减轻数据库压力。
- 熔断与降级：当检测到后端压力过大时，及时启用熔断机制，拒绝一部分请求或返回默认值，保护系统核心服务不被拖垮。S